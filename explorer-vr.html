<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Latent Space VR</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #08080c;
      color: #e8e8ec;
      overflow: hidden;
    }
    #app {
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    .header {
      padding: 12px 20px;
      border-bottom: 1px solid #1a1a24;
      display: flex;
      align-items: center;
      gap: 16px;
      background: #0c0c12;
      flex-wrap: wrap;
      z-index: 100;
    }
    .header h1 {
      font-size: 16px;
      font-weight: 500;
      color: #a0a0b0;
    }
    .upload-btn {
      padding: 8px 16px;
      background: #2563eb;
      border: none;
      border-radius: 6px;
      color: white;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
    }
    .upload-btn:hover { background: #1d4ed8; }
    .upload-btn:disabled { opacity: 0.6; cursor: wait; }
    .status {
      color: #606070;
      font-size: 13px;
      flex: 1;
    }
    .server-status {
      font-size: 11px;
      padding: 4px 8px;
      background: #18182b;
      border-radius: 4px;
      color: #6366f1;
    }
    .server-status.offline {
      background: #3b1818;
      color: #ef4444;
    }
    #canvas-container {
      flex: 1;
      position: relative;
    }
    .info-panel {
      position: absolute;
      bottom: 60px;
      left: 20px;
      background: rgba(12, 12, 18, 0.9);
      padding: 12px 16px;
      border-radius: 8px;
      border: 1px solid #1a1a24;
      font-size: 13px;
      display: none;
      z-index: 50;
    }
    .info-panel.visible { display: block; }
    .info-panel .idx { color: #6366f1; margin-bottom: 4px; }
    .info-panel .time { color: #606070; }
    .info-panel .playing { color: #22c55e; margin-top: 4px; }
    .footer {
      padding: 10px 20px;
      border-top: 1px solid #1a1a24;
      font-size: 12px;
      color: #404050;
      background: #0c0c12;
      display: flex;
      align-items: center;
      gap: 12px;
      z-index: 100;
    }
    .footer-text { 
      flex-shrink: 0;
      flex: 1;
    }
    .playbar-container {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
      opacity: 0.3;
      pointer-events: none;
    }
    .playbar-container.enabled {
      opacity: 1;
      pointer-events: auto;
    }
    .playbar-time {
      font-size: 12px;
      color: #a0a0b0;
      font-variant-numeric: tabular-nums;
      min-width: 45px;
    }
    .playbar-time.end { text-align: right; }
    .volume-control {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-left: 10px;
    }
    .volume-icon {
      font-size: 14px;
      cursor: pointer;
      user-select: none;
    }
    .volume-slider {
      width: 70px;
      height: 4px;
      -webkit-appearance: none;
      appearance: none;
      background: #333;
      border-radius: 2px;
      cursor: pointer;
    }
    .volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      background: #fff;
      border-radius: 50%;
      cursor: pointer;
    }
    .playbar {
      flex: 1;
      height: 6px;
      background: #1a1a24;
      border-radius: 3px;
      cursor: pointer;
      position: relative;
    }
    .playbar-progress {
      height: 100%;
      background: linear-gradient(90deg, #ef4444, #f97316, #eab308, #22c55e, #06b6d4, #8b5cf6);
      border-radius: 3px;
      width: 0%;
      pointer-events: none;
    }
    .playbar-handle {
      position: absolute;
      left: 0%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 14px;
      height: 14px;
      background: #fff;
      border-radius: 50%;
      box-shadow: 0 2px 6px rgba(0,0,0,0.5);
      pointer-events: none;
    }
    input[type="file"] { display: none; }
    
    .song-select {
      padding: 8px 12px;
      background: #1a1a24;
      border: 1px solid #333;
      border-radius: 6px;
      color: #e8e8ec;
      font-size: 13px;
      cursor: pointer;
      max-width: 250px;
    }
    .song-select:hover { border-color: #6366f1; }
    .song-select:focus { outline: none; border-color: #6366f1; }
    .song-select option {
      background: #1a1a24;
      color: #e8e8ec;
    }
    
    /* VR Button styling */
    #VRButton {
      position: absolute !important;
      bottom: 80px !important;
      left: 50% !important;
      transform: translateX(-50%) !important;
    }
    
    .vr-instructions {
      position: absolute;
      bottom: 140px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(99, 102, 241, 0.9);
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      font-size: 13px;
      text-align: center;
      max-width: 400px;
      z-index: 50;
      display: none;
    }
    .vr-instructions.visible { display: block; }
  </style>
</head>
<body>
  <div id="app">
    <div class="header">
      <h1>ðŸ¥½ Latent Space VR</h1>
      <select class="song-select" id="song-select">
        <option value="">â€” Select a song â€”</option>
      </select>
      <label class="upload-btn" id="upload-btn">
        Upload
        <input type="file" id="file-input" accept="audio/*">
      </label>
      <button class="upload-btn" id="play-btn" style="background:#22c55e;display:none">â–¶ Play</button>
      <span class="status" id="status">Select a song or upload audio</span>
      <span class="server-status" id="server-status">checking...</span>
    </div>
    <div id="canvas-container"></div>
    <div class="info-panel" id="info-panel">
      <div class="idx" id="info-idx">Latent #0</div>
      <div class="time" id="info-time">Time: 0.000s</div>
      <div class="playing" id="info-playing" style="display:none">â–¶ Playing</div>
    </div>
    <div class="vr-instructions" id="vr-instructions">
      <strong>VR Controls:</strong><br>
      Point controller â†’ Select latent<br>
      Trigger â†’ Play sound <em>from that point</em><br>
      Thumbstick â†’ Fly through space<br>
      Grip â†’ Toggle play/pause<br>
      <strong style="color:#22c55e">ðŸ”Š Spatial Audio:</strong> Sound follows the playhead!
    </div>
    <div class="footer" id="footer">
      <span class="footer-text" id="footer-text">Upload audio, then enter VR</span>
      <div class="playbar-container" id="playbar-container">
        <span class="playbar-time" id="playbar-current">0:00</span>
        <div class="playbar" id="playbar">
          <div class="playbar-progress" id="playbar-progress"></div>
          <div class="playbar-handle" id="playbar-handle"></div>
        </div>
        <span class="playbar-time end" id="playbar-duration">0:00</span>
        <div class="volume-control">
          <span class="volume-icon" id="volume-icon">ðŸ”Š</span>
          <input type="range" id="volume-slider" min="0" max="100" value="100" class="volume-slider">
        </div>
      </div>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

    const API_URL = window.location.origin;
    
    // State
    let latents = [];
    let projection = [];
    let audioInfo = null;
    let hoveredIdx = null;
    let selectedIdx = null;
    let isPlaying = false;
    let audioContext = null;
    let currentSource = null;
    
    // Three.js
    let scene, camera, renderer, points, material;
    let spherical = { theta: 0, phi: Math.PI / 2, radius: 4 };
    let isDragging = false;
    let previousMouse = { x: 0, y: 0 };
    let autoRotate = true;
    
    // Playback
    let playbackAudio = null;
    let playbackStartTime = 0;
    let isFullPlaying = false;
    let glowPoints = null;
    let baseColors = null;
    let trailLine = null;
    
    // Spatial audio
    let audioListener = null;
    let spatialPanner = null;
    let playheadAudioSource = null; // Positional audio that follows playhead
    
    // VR state
    let isInVR = false;
    let controller1, controller2;
    let controllerGrip1, controllerGrip2;
    let vrRaycaster;
    let vrPointerLine;
    let vrHoveredIdx = null;
    let userGroup; // Parent group for locomotion
    let lastThumbstickY = 0;
    let flySpeed = 0;
    
    // Cluster state
    let clusterAssignments = [];
    let clusterMeshes = [];
    let clusterTriggerTimes = [];
    let clusterK = 8;
    let clusterCentroids = [];
    
    // DOM
    const container = document.getElementById('canvas-container');
    const statusEl = document.getElementById('status');
    const serverStatusEl = document.getElementById('server-status');
    const uploadBtn = document.getElementById('upload-btn');
    const fileInput = document.getElementById('file-input');
    const infoPanel = document.getElementById('info-panel');
    const infoIdx = document.getElementById('info-idx');
    const infoTime = document.getElementById('info-time');
    const infoPlaying = document.getElementById('info-playing');
    const footerText = document.getElementById('footer-text');
    const playBtn = document.getElementById('play-btn');
    const vrInstructions = document.getElementById('vr-instructions');
    const songSelect = document.getElementById('song-select');

    // Fetch and populate song list
    async function loadSongList() {
      try {
        const response = await fetch(`${API_URL}/songs`);
        const data = await response.json();
        
        songSelect.innerHTML = '<option value="">â€” Select a song â€”</option>';
        
        for (const song of data.songs) {
          const opt = document.createElement('option');
          opt.value = song;
          // Clean up filename for display (remove extension, decode URI)
          const displayName = decodeURIComponent(song.replace(/\.[^.]+$/, ''));
          opt.textContent = displayName;
          songSelect.appendChild(opt);
        }
        
        if (data.songs.length > 0) {
          statusEl.textContent = `${data.songs.length} songs available â€¢ Select or upload`;
        }
      } catch (err) {
        console.error('Failed to load songs:', err);
      }
    }
    
    // Handle song selection
    songSelect.addEventListener('change', async (e) => {
      const filename = e.target.value;
      if (!filename) return;
      
      statusEl.textContent = `Loading ${filename}...`;
      
      try {
        // Fetch the song file
        const response = await fetch(`${API_URL}/songs/${encodeURIComponent(filename)}`);
        if (!response.ok) throw new Error('Failed to fetch song');
        
        const blob = await response.blob();
        const file = new File([blob], filename, { type: blob.type });
        
        // Process it like an uploaded file
        await processFile(file);
      } catch (err) {
        statusEl.textContent = `Error: ${err.message}`;
        console.error(err);
      }
    });

    async function checkServer() {
      try {
        const r = await fetch(`${API_URL}/health`);
        const data = await r.json();
        serverStatusEl.textContent = data.vae_loaded ? 'VAE loaded' : 'Ready';
        serverStatusEl.classList.remove('offline');
      } catch {
        serverStatusEl.textContent = 'Server offline';
        serverStatusEl.classList.add('offline');
      }
    }

    async function processFile(file) {
      uploadBtn.textContent = 'Processing...';
      uploadBtn.style.pointerEvents = 'none';
      statusEl.textContent = `Uploading ${file.name}...`;
      
      if (isFullPlaying) stopFullPlayback();
      playbackAudio = null;
      
      try {
        const formData = new FormData();
        formData.append('file', file);
        
        const response = await fetch(`${API_URL}/encode_stream`, {
          method: 'POST',
          body: formData
        });
        
        if (!response.ok) throw new Error(await response.text());
        
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n\n');
          buffer = lines.pop() || '';
          
          for (const line of lines) {
            if (!line.startsWith('data: ')) continue;
            const data = JSON.parse(line.slice(6));
            
            if (data.stage === 'cached') {
              statusEl.textContent = 'Loading from cache...';
            } else if (data.stage === 'loading_vae') {
              statusEl.textContent = 'Loading VAE...';
            } else if (data.stage === 'encoding') {
              statusEl.textContent = 'Encoding audio...';
            } else if (data.stage === 'umap') {
              statusEl.textContent = `Running UMAP on ${data.num_latents} latents...`;
              audioInfo = { numLatents: data.num_latents, samplesPerLatent: 2048 };
              projection = Array.from({ length: data.num_latents }, () => [
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2
              ]);
              initThreeJS();
            } else if (data.stage === 'done') {
              latents = data.latents;
              audioInfo = {
                duration: data.duration_seconds,
                numLatents: data.num_latents,
                samplesPerLatent: data.samples_per_latent
              };
              
              if (!points) {
                projection = data.projection;
                initThreeJS();
                buildClusters();
              } else {
                animateToProjection(data.projection);
              }
              
              statusEl.textContent = `${data.num_latents} latents â€¢ ${data.duration_seconds.toFixed(1)}s â€¢ Enter VR!`;
              footerText.textContent = `${data.num_latents} points â€¢ VR Ready`;
              playBtn.style.display = 'inline-block';
              vrInstructions.classList.add('visible');
            } else if (data.stage === 'error') {
              throw new Error(data.error);
            }
          }
        }
        
      } catch (err) {
        statusEl.textContent = `Error: ${err.message}`;
      } finally {
        uploadBtn.textContent = 'Upload Audio';
        uploadBtn.style.pointerEvents = 'auto';
      }
    }
    
    let animationId = null;
    function animateToProjection(targetProjection) {
      if (animationId) cancelAnimationFrame(animationId);
      if (!points) return;
      
      const startPositions = [...points.geometry.attributes.position.array];
      const startTime = performance.now();
      const duration = 1500;
      
      function animate() {
        const elapsed = performance.now() - startTime;
        const t = Math.min(elapsed / duration, 1);
        const ease = 1 - Math.pow(1 - t, 3);
        
        const positions = points.geometry.attributes.position.array;
        targetProjection.forEach((p, i) => {
          // VR scale: 3x larger so you're inside it
          positions[i * 3] = startPositions[i * 3] + (p[0] * 6 - startPositions[i * 3]) * ease;
          positions[i * 3 + 1] = startPositions[i * 3 + 1] + (p[1] * 6 - startPositions[i * 3 + 1]) * ease;
          positions[i * 3 + 2] = startPositions[i * 3 + 2] + (p[2] * 6 - startPositions[i * 3 + 2]) * ease;
        });
        points.geometry.attributes.position.needsUpdate = true;
        
        if (t < 1) {
          animationId = requestAnimationFrame(animate);
        } else {
          projection = targetProjection;
          animationId = null;
          buildClusters();
        }
      }
      animate();
    }

    fileInput.addEventListener('change', (e) => {
      const file = e.target.files?.[0];
      if (file) processFile(file);
      fileInput.value = '';
    });

    document.body.addEventListener('dragover', (e) => {
      e.preventDefault();
      document.body.style.background = '#12121a';
    });
    document.body.addEventListener('dragleave', (e) => {
      e.preventDefault();
      document.body.style.background = '#08080c';
    });
    document.body.addEventListener('drop', (e) => {
      e.preventDefault();
      document.body.style.background = '#08080c';
      const file = e.dataTransfer.files?.[0];
      if (file && file.type.startsWith('audio/')) processFile(file);
    });

    async function playLatent(idx) {
      if (idx === null || idx >= audioInfo?.numLatents) return;
      if (isFullPlaying) return;
      
      if (currentSource) {
        currentSource.stop();
        currentSource = null;
      }
      
      isPlaying = true;
      selectedIdx = idx;
      infoPlaying.style.display = 'block';
      
      try {
        const response = await fetch(`${API_URL}/play`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ index: idx })
        });
        
        if (!response.ok) throw new Error('Play failed');
        
        const arrayBuffer = await response.arrayBuffer();
        
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        const source = audioContext.createBufferSource();
        source.buffer = audioBuffer;
        
        // Spatial audio for single latent playback in VR
        if (isInVR && projection[idx]) {
          const pointPanner = audioContext.createPanner();
          pointPanner.panningModel = 'HRTF';
          pointPanner.distanceModel = 'inverse';
          pointPanner.refDistance = 0.5;
          pointPanner.maxDistance = 30;
          pointPanner.rolloffFactor = 1.5;
          
          // Position at the latent's location (VR scale)
          const p = projection[idx];
          pointPanner.positionX.setValueAtTime(p[0] * 6, audioContext.currentTime);
          pointPanner.positionY.setValueAtTime(p[1] * 6, audioContext.currentTime);
          pointPanner.positionZ.setValueAtTime(p[2] * 6, audioContext.currentTime);
          
          source.connect(pointPanner);
          pointPanner.connect(audioContext.destination);
        } else {
          source.connect(audioContext.destination);
        }
        
        source.onended = () => {
          isPlaying = false;
          selectedIdx = null;
          infoPlaying.style.display = 'none';
        };
        source.start();
        currentSource = source;
        
      } catch (err) {
        console.error('Playback error:', err);
        isPlaying = false;
        selectedIdx = null;
        infoPlaying.style.display = 'none';
      }
    }
    
    function buildClusters() {
      if (!projection.length || !scene) return;
      
      clusterMeshes.forEach(m => scene.remove(m));
      clusterMeshes = [];
      clusterTriggerTimes = new Array(clusterK).fill(0);
      
      // VR scale
      const pts = projection.map(p => [p[0] * 6, p[1] * 6, p[2] * 6]);
      
      // K-means++
      let centroids = [];
      centroids.push([...pts[Math.floor(Math.random() * pts.length)]]);
      
      for (let i = 1; i < clusterK && i < pts.length; i++) {
        const dists = pts.map(p => {
          let minD = Infinity;
          centroids.forEach(c => {
            const d = (p[0]-c[0])**2 + (p[1]-c[1])**2 + (p[2]-c[2])**2;
            if (d < minD) minD = d;
          });
          return minD;
        });
        
        const totalDist = dists.reduce((a, b) => a + b, 0);
        let r = Math.random() * totalDist;
        let chosen = 0;
        for (let j = 0; j < dists.length; j++) {
          r -= dists[j];
          if (r <= 0) { chosen = j; break; }
        }
        centroids.push([...pts[chosen]]);
      }
      
      for (let iter = 0; iter < 50; iter++) {
        clusterAssignments = pts.map(p => {
          let minDist = Infinity, minIdx = 0;
          centroids.forEach((c, i) => {
            const d = (p[0]-c[0])**2 + (p[1]-c[1])**2 + (p[2]-c[2])**2;
            if (d < minDist) { minDist = d; minIdx = i; }
          });
          return minIdx;
        });
        
        const newCentroids = centroids.map(() => [0, 0, 0]);
        const counts = new Array(clusterK).fill(0);
        pts.forEach((p, i) => {
          const c = clusterAssignments[i];
          newCentroids[c][0] += p[0];
          newCentroids[c][1] += p[1];
          newCentroids[c][2] += p[2];
          counts[c]++;
        });
        
        let converged = true;
        const newCentroidsFinal = newCentroids.map((c, i) => {
          if (counts[i] === 0) return centroids[i];
          const nc = [c[0]/counts[i], c[1]/counts[i], c[2]/counts[i]];
          const moved = (nc[0]-centroids[i][0])**2 + (nc[1]-centroids[i][1])**2 + (nc[2]-centroids[i][2])**2;
          if (moved > 0.0001) converged = false;
          return nc;
        });
        centroids = newCentroidsFinal;
        if (converged) break;
      }
      
      clusterCentroids = centroids;
      
      // Glow texture
      const glowCanvas = document.createElement('canvas');
      glowCanvas.width = 128;
      glowCanvas.height = 128;
      const ctx = glowCanvas.getContext('2d');
      const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
      gradient.addColorStop(0, 'rgba(255,255,255,1)');
      gradient.addColorStop(0.3, 'rgba(255,255,255,0.5)');
      gradient.addColorStop(0.6, 'rgba(255,255,255,0.15)');
      gradient.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 128, 128);
      const glowTexture = new THREE.CanvasTexture(glowCanvas);
      
      for (let k = 0; k < clusterK; k++) {
        const clusterPts = pts.filter((_, i) => clusterAssignments[i] === k);
        if (clusterPts.length < 2) continue;
        
        const t = k / clusterK;
        const color = new THREE.Color().setHSL(t, 0.7, 0.5);
        
        const center = centroids[k];
        let maxDist = 0;
        clusterPts.forEach(p => {
          const d = Math.sqrt((p[0]-center[0])**2 + (p[1]-center[1])**2 + (p[2]-center[2])**2);
          if (d > maxDist) maxDist = d;
        });
        
        const spriteSize = maxDist * 2.5;
        
        const mat = new THREE.SpriteMaterial({
          map: glowTexture,
          color: color,
          transparent: true,
          opacity: 0.35,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });
        
        const sprite = new THREE.Sprite(mat);
        sprite.position.set(center[0], center[1], center[2]);
        sprite.scale.set(spriteSize, spriteSize, 1);
        sprite.userData = { baseOpacity: 0.35, clusterIdx: k };
        scene.add(sprite);
        clusterMeshes.push(sprite);
      }
    }
    
    function updateClusterVisualization(currentCluster) {
      const now = performance.now();
      
      if (currentCluster >= 0 && currentCluster < clusterK) {
        clusterTriggerTimes[currentCluster] = now;
      }
      
      clusterMeshes.forEach(mesh => {
        const k = mesh.userData.clusterIdx;
        const baseOpacity = mesh.userData.baseOpacity;
        const timeSinceTrigger = now - clusterTriggerTimes[k];
        const fadeDuration = 80;
        
        let opacity;
        if (timeSinceTrigger < fadeDuration) {
          const t = timeSinceTrigger / fadeDuration;
          const fade = t * t * t;
          opacity = 1.0 - fade * (1.0 - baseOpacity);
        } else {
          opacity = baseOpacity;
        }
        
        mesh.material.opacity = opacity;
      });
    }
    
    // Playbar
    const playbarContainer = document.getElementById('playbar-container');
    const playbar = document.getElementById('playbar');
    const playbarProgress = document.getElementById('playbar-progress');
    const playbarHandle = document.getElementById('playbar-handle');
    const playbarCurrent = document.getElementById('playbar-current');
    const playbarDuration = document.getElementById('playbar-duration');
    const volumeSlider = document.getElementById('volume-slider');
    const volumeIcon = document.getElementById('volume-icon');
    
    let gainNode = null;
    let currentVolume = 1.0;
    
    volumeSlider.addEventListener('input', (e) => {
      currentVolume = e.target.value / 100;
      if (gainNode) gainNode.gain.value = currentVolume;
      volumeIcon.textContent = currentVolume === 0 ? 'ðŸ”‡' : currentVolume < 0.5 ? 'ðŸ”‰' : 'ðŸ”Š';
    });
    
    volumeIcon.addEventListener('click', () => {
      if (currentVolume > 0) {
        volumeSlider.value = 0;
        currentVolume = 0;
      } else {
        volumeSlider.value = 100;
        currentVolume = 1;
      }
      if (gainNode) gainNode.gain.value = currentVolume;
      volumeIcon.textContent = currentVolume === 0 ? 'ðŸ”‡' : 'ðŸ”Š';
    });
    
    playBtn.addEventListener('click', toggleFullPlayback);
    
    function formatTime(seconds) {
      const m = Math.floor(seconds / 60);
      const s = Math.floor(seconds % 60);
      return `${m}:${s.toString().padStart(2, '0')}`;
    }
    
    async function toggleFullPlayback() {
      if (isFullPlaying) {
        stopFullPlayback();
        return;
      }
      await startPlaybackAt(0);
    }
    
    async function startPlaybackAt(offsetSeconds) {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      
      if (!gainNode) {
        gainNode = audioContext.createGain();
        gainNode.gain.value = currentVolume;
      }
      
      // Setup spatial audio panner for VR
      if (!spatialPanner) {
        spatialPanner = audioContext.createPanner();
        spatialPanner.panningModel = 'HRTF'; // Head-related transfer function for realistic 3D
        spatialPanner.distanceModel = 'inverse';
        spatialPanner.refDistance = 1;
        spatialPanner.maxDistance = 50;
        spatialPanner.rolloffFactor = 1;
        spatialPanner.coneInnerAngle = 360;
        spatialPanner.coneOuterAngle = 360;
        spatialPanner.coneOuterGain = 0;
        
        // Chain: source -> panner -> gain -> destination
        spatialPanner.connect(gainNode);
        gainNode.connect(audioContext.destination);
      }
      
      if (currentSource) {
        currentSource.onended = null;
        currentSource.stop();
        currentSource = null;
      }
      
      playBtn.textContent = 'Loading...';
      
      try {
        if (!playbackAudio) {
          const response = await fetch(`${API_URL}/audio_full`);
          if (!response.ok) throw new Error('Failed to load audio');
          const arrayBuffer = await response.arrayBuffer();
          playbackAudio = await audioContext.decodeAudioData(arrayBuffer);
        }
        
        const source = audioContext.createBufferSource();
        source.buffer = playbackAudio;
        
        // In VR: use spatial panner. Desktop: direct to gain
        if (isInVR) {
          source.connect(spatialPanner);
        } else {
          source.connect(gainNode);
          gainNode.connect(audioContext.destination);
        }
        
        source.onended = stopFullPlayback;
        
        const duration = playbackAudio.duration;
        offsetSeconds = Math.max(0, Math.min(offsetSeconds, duration - 0.1));
        
        playbackStartTime = audioContext.currentTime - offsetSeconds;
        source.start(0, offsetSeconds);
        currentSource = source;
        isFullPlaying = true;
        
        playBtn.textContent = 'â¹ Stop';
        playBtn.style.background = '#ef4444';
        
        playbarContainer.classList.add('enabled');
        playbarDuration.textContent = formatTime(duration);
        
      } catch (err) {
        console.error('Playback error:', err);
        playBtn.textContent = 'â–¶ Play';
      }
    }
    
    playbar.addEventListener('click', (e) => {
      if (!playbackAudio) return;
      const rect = playbar.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const pct = x / rect.width;
      const seekTime = pct * playbackAudio.duration;
      if (isFullPlaying) startPlaybackAt(seekTime);
    });
    
    document.addEventListener('keydown', (e) => {
      if (e.target.tagName === 'INPUT') return;
      
      if (e.code === 'Space') {
        e.preventDefault();
        if (audioInfo) toggleFullPlayback();
      } else if (e.code === 'ArrowLeft' && isFullPlaying && playbackAudio) {
        e.preventDefault();
        const elapsed = audioContext.currentTime - playbackStartTime;
        startPlaybackAt(Math.max(0, elapsed - 5));
      } else if (e.code === 'ArrowRight' && isFullPlaying && playbackAudio) {
        e.preventDefault();
        const elapsed = audioContext.currentTime - playbackStartTime;
        startPlaybackAt(Math.min(playbackAudio.duration, elapsed + 5));
      }
    });
    
    function stopFullPlayback() {
      if (currentSource) {
        currentSource.stop();
        currentSource = null;
      }
      isFullPlaying = false;
      playBtn.textContent = 'â–¶ Play';
      playBtn.style.background = '#22c55e';
      
      if (points && baseColors) {
        const colors = points.geometry.attributes.color.array;
        for (let i = 0; i < baseColors.length; i++) colors[i] = baseColors[i];
        points.geometry.attributes.color.needsUpdate = true;
      }
      
      if (glowPoints && scene) { scene.remove(glowPoints); glowPoints = null; }
      if (trailLine && scene) { scene.remove(trailLine); trailLine = null; }
      
      playbarContainer.classList.remove('enabled');
      playbarProgress.style.width = '0%';
      playbarHandle.style.left = '0%';
      playbarCurrent.textContent = '0:00';
    }
    
    function updatePlaybackVisualization() {
      if (!isFullPlaying || !audioContext || !projection.length) return;
      
      const elapsed = audioContext.currentTime - playbackStartTime;
      const samplePos = elapsed * 44100;
      const latentIdx = Math.floor(samplePos / (audioInfo?.samplesPerLatent || 2048));
      const progress = (samplePos % (audioInfo?.samplesPerLatent || 2048)) / (audioInfo?.samplesPerLatent || 2048);
      
      if (playbackAudio) {
        const pct = (elapsed / playbackAudio.duration) * 100;
        playbarProgress.style.width = `${Math.min(100, pct)}%`;
        playbarHandle.style.left = `${Math.min(100, pct)}%`;
        playbarCurrent.textContent = formatTime(elapsed);
      }
      
      if (latentIdx >= projection.length) return;
      
      // Color trail on points
      if (points && baseColors) {
        const colors = points.geometry.attributes.color.array;
        const trailLength = 8;
        
        for (let i = 0; i < projection.length; i++) {
          const dist = latentIdx - i;
          if (dist >= 0 && dist < trailLength) {
            const fade = 1 - dist / trailLength;
            const glow = fade * fade;
            colors[i * 3] = baseColors[i * 3] + (1 - baseColors[i * 3]) * glow;
            colors[i * 3 + 1] = baseColors[i * 3 + 1] + (1 - baseColors[i * 3 + 1]) * glow;
            colors[i * 3 + 2] = baseColors[i * 3 + 2] + (0.3 - baseColors[i * 3 + 2]) * glow;
          } else {
            colors[i * 3] = baseColors[i * 3] * 0.4;
            colors[i * 3 + 1] = baseColors[i * 3 + 1] * 0.4;
            colors[i * 3 + 2] = baseColors[i * 3 + 2] * 0.4;
          }
        }
        points.geometry.attributes.color.needsUpdate = true;
        
        // Trail line
        const trailLineLength = 25;
        const trailStart = Math.max(0, latentIdx - trailLineLength);
        
        if (!trailLine && projection.length > 1) {
          const maxVerts = projection.length;
          const positions = new Float32Array(maxVerts * 3);
          const lineColors = new Float32Array(maxVerts * 3);
          const geom = new THREE.BufferGeometry();
          geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          geom.setAttribute('color', new THREE.BufferAttribute(lineColors, 3));
          geom.setDrawRange(0, 0);
          const mat = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.9 });
          trailLine = new THREE.Line(geom, mat);
          scene.add(trailLine);
        }
        
        if (trailLine && latentIdx > 0) {
          const positions = trailLine.geometry.attributes.position.array;
          const lineColors = trailLine.geometry.attributes.color.array;
          const numVerts = Math.min(latentIdx - trailStart + 1, latentIdx + 1);
          
          for (let i = 0; i < numVerts; i++) {
            const idx = trailStart + i;
            if (idx >= projection.length) break;
            const p = projection[idx];
            // VR scale
            positions[i * 3] = p[0] * 6;
            positions[i * 3 + 1] = p[1] * 6;
            positions[i * 3 + 2] = p[2] * 6;
            
            const fade = i / (numVerts - 1 || 1);
            const brightness = 0.2 + fade * 0.8;
            const t = idx / projection.length;
            const color = new THREE.Color().setHSL(t, 0.85, 0.5 * brightness + 0.3);
            lineColors[i * 3] = color.r;
            lineColors[i * 3 + 1] = color.g;
            lineColors[i * 3 + 2] = color.b;
          }
          
          trailLine.geometry.attributes.position.needsUpdate = true;
          trailLine.geometry.attributes.color.needsUpdate = true;
          trailLine.geometry.setDrawRange(0, numVerts);
        }
      }
      
      // Glowing playhead sphere
      if (latentIdx < projection.length - 1) {
        const p0 = projection[latentIdx];
        const p1 = projection[latentIdx + 1];
        // VR scale
        const x = (p0[0] + (p1[0] - p0[0]) * progress) * 6;
        const y = (p0[1] + (p1[1] - p0[1]) * progress) * 6;
        const z = (p0[2] + (p1[2] - p0[2]) * progress) * 6;
        
        if (!glowPoints) {
          glowPoints = new THREE.Group();
          
          // Larger for VR visibility
          const coreGeom = new THREE.SphereGeometry(0.15, 16, 16);
          const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
          const core = new THREE.Mesh(coreGeom, coreMat);
          core.name = 'core';
          glowPoints.add(core);
          
          const haloGeom = new THREE.SphereGeometry(0.35, 16, 16);
          const haloMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.35 });
          const halo = new THREE.Mesh(haloGeom, haloMat);
          halo.name = 'halo';
          glowPoints.add(halo);
          
          scene.add(glowPoints);
        }
        glowPoints.position.set(x, y, z);
        
        const t = latentIdx / projection.length;
        const core = glowPoints.getObjectByName('core');
        const halo = glowPoints.getObjectByName('halo');
        if (core) core.material.color.setHSL(t, 0.9, 0.85);
        if (halo) halo.material.color.setHSL(t, 0.9, 0.6);
        
        // Update spatial audio position - sound comes from playhead!
        if (spatialPanner && isInVR) {
          spatialPanner.positionX.setValueAtTime(x, audioContext.currentTime);
          spatialPanner.positionY.setValueAtTime(y, audioContext.currentTime);
          spatialPanner.positionZ.setValueAtTime(z, audioContext.currentTime);
        }
      }
      
      // Clusters
      if (clusterAssignments.length > 0 && latentIdx < clusterAssignments.length) {
        updateClusterVisualization(clusterAssignments[latentIdx]);
      }
    }

    // ===== VR SETUP =====
    
    function setupVR() {
      // Enable WebXR
      renderer.xr.enabled = true;
      
      // Add VR button
      const vrButton = VRButton.createButton(renderer);
      document.body.appendChild(vrButton);
      
      // Session start/end handlers
      renderer.xr.addEventListener('sessionstart', () => {
        isInVR = true;
        vrInstructions.classList.remove('visible');
        console.log('Entered VR');
      });
      
      renderer.xr.addEventListener('sessionend', () => {
        isInVR = false;
        console.log('Exited VR');
      });
      
      // Controller model factory
      const controllerModelFactory = new XRControllerModelFactory();
      
      // Controller 0 (right hand typically)
      controller1 = renderer.xr.getController(0);
      controller1.addEventListener('selectstart', onSelectStart);
      controller1.addEventListener('selectend', onSelectEnd);
      controller1.addEventListener('squeezestart', onSqueezeStart); // Grip button
      scene.add(controller1);
      
      controllerGrip1 = renderer.xr.getControllerGrip(0);
      controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
      scene.add(controllerGrip1);
      
      // Controller 1 (left hand typically)
      controller2 = renderer.xr.getController(1);
      controller2.addEventListener('selectstart', onSelectStart);
      controller2.addEventListener('selectend', onSelectEnd);
      controller2.addEventListener('squeezestart', onSqueezeStart);
      scene.add(controller2);
      
      controllerGrip2 = renderer.xr.getControllerGrip(1);
      controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
      scene.add(controllerGrip2);
      
      // Pointer line from controller
      const lineGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, 0, -10)
      ]);
      const lineMaterial = new THREE.LineBasicMaterial({ 
        color: 0x6366f1,
        transparent: true,
        opacity: 0.6
      });
      vrPointerLine = new THREE.Line(lineGeometry, lineMaterial);
      controller1.add(vrPointerLine);
      
      // Also add to controller 2
      const vrPointerLine2 = new THREE.Line(lineGeometry.clone(), lineMaterial.clone());
      controller2.add(vrPointerLine2);
      
      // VR raycaster
      vrRaycaster = new THREE.Raycaster();
      vrRaycaster.params.Points.threshold = 0.25; // Larger threshold for VR
    }
    
    function onSelectStart(event) {
      // Trigger pressed - play the hovered latent
      if (vrHoveredIdx !== null) {
        playLatent(vrHoveredIdx);
      }
    }
    
    function onSelectEnd(event) {
      // Trigger released
    }
    
    function onSqueezeStart(event) {
      // Grip button - toggle playback
      if (audioInfo) {
        toggleFullPlayback();
      }
    }
    
    function updateVRInput() {
      if (!isInVR || !renderer.xr.isPresenting) return;
      
      const session = renderer.xr.getSession();
      if (!session) return;
      
      // Get input sources for thumbstick
      for (const source of session.inputSources) {
        if (!source.gamepad) continue;
        
        const gamepad = source.gamepad;
        
        // Thumbstick Y axis (index 3 typically) for forward/back movement
        // Thumbstick X axis (index 2) for rotation
        if (gamepad.axes.length >= 4) {
          const thumbY = gamepad.axes[3]; // Forward/back
          const thumbX = gamepad.axes[2]; // Left/right rotation
          
          // Apply deadzone
          const deadzone = 0.15;
          
          if (Math.abs(thumbY) > deadzone) {
            // Get camera direction
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            
            // Move in camera direction
            const speed = thumbY * -0.08; // Negative because forward is negative Y
            camera.position.addScaledVector(cameraDirection, speed);
          }
          
          if (Math.abs(thumbX) > deadzone) {
            // Rotate camera
            spherical.theta += thumbX * 0.03;
          }
        }
      }
      
      // Update VR raycasting
      updateVRRaycast();
    }
    
    function updateVRRaycast() {
      if (!points || !vrRaycaster) return;
      
      // Raycast from right controller
      const tempMatrix = new THREE.Matrix4();
      tempMatrix.identity().extractRotation(controller1.matrixWorld);
      
      vrRaycaster.ray.origin.setFromMatrixPosition(controller1.matrixWorld);
      vrRaycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
      
      const intersects = vrRaycaster.intersectObject(points);
      
      if (intersects.length > 0) {
        vrHoveredIdx = intersects[0].index;
        
        // Update pointer line to show hit
        const positions = vrPointerLine.geometry.attributes.position.array;
        positions[5] = -intersects[0].distance; // Z of end point
        vrPointerLine.geometry.attributes.position.needsUpdate = true;
        vrPointerLine.material.color.setHex(0x22c55e); // Green when hovering
        vrPointerLine.material.opacity = 1;
      } else {
        vrHoveredIdx = null;
        
        // Reset pointer line
        const positions = vrPointerLine.geometry.attributes.position.array;
        positions[5] = -10;
        vrPointerLine.geometry.attributes.position.needsUpdate = true;
        vrPointerLine.material.color.setHex(0x6366f1); // Purple default
        vrPointerLine.material.opacity = 0.6;
      }
    }

    // Three.js init
    function initThreeJS() {
      container.innerHTML = '';
      
      const width = container.clientWidth;
      const height = container.clientHeight;
      
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x08080c);
      
      // Add some ambient fog for depth
      scene.fog = new THREE.Fog(0x08080c, 15, 40);
      
      camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
      camera.position.z = 4;
      
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(width, height);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      container.appendChild(renderer.domElement);
      
      // Setup VR
      setupVR();
      
      // Points - VR scale (3x larger)
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(projection.length * 3);
      const colors = new Float32Array(projection.length * 3);
      
      projection.forEach((p, i) => {
        positions[i * 3] = p[0] * 6;
        positions[i * 3 + 1] = p[1] * 6;
        positions[i * 3 + 2] = p[2] * 6;
        
        const t = i / projection.length;
        const color = new THREE.Color().setHSL(t * 0.7 + 0.55, 0.75, 0.55);
        colors[i * 3] = color.r;
        colors[i * 3 + 1] = color.g;
        colors[i * 3 + 2] = color.b;
      });
      
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      
      baseColors = new Float32Array(colors);
      
      material = new THREE.PointsMaterial({
        size: 0.12, // Larger for VR
        vertexColors: true,
        transparent: true,
        opacity: 0.9,
        sizeAttenuation: true
      });
      
      points = new THREE.Points(geometry, material);
      scene.add(points);
      
      // Mouse raycaster for desktop
      const raycaster = new THREE.Raycaster();
      raycaster.params.Points.threshold = 0.2;
      const mouse = new THREE.Vector2();
      
      function updateCamera() {
        if (isInVR) return; // Don't update in VR mode
        camera.position.x = spherical.radius * Math.sin(spherical.phi) * Math.sin(spherical.theta);
        camera.position.y = spherical.radius * Math.cos(spherical.phi);
        camera.position.z = spherical.radius * Math.sin(spherical.phi) * Math.cos(spherical.theta);
        camera.lookAt(0, 0, 0);
      }
      
      container.addEventListener('mousedown', (e) => {
        if (e.button === 0) {
          isDragging = true;
          autoRotate = false;
          previousMouse = { x: e.clientX, y: e.clientY };
        }
      });
      
      container.addEventListener('mouseup', () => { isDragging = false; });
      
      container.addEventListener('mousemove', (e) => {
        if (isInVR) return;
        
        const rect = container.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        
        if (isDragging) {
          const deltaX = e.clientX - previousMouse.x;
          const deltaY = e.clientY - previousMouse.y;
          spherical.theta -= deltaX * 0.008;
          spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi - deltaY * 0.008));
          previousMouse = { x: e.clientX, y: e.clientY };
          updateCamera();
        }
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(points);
        
        if (intersects.length > 0) {
          hoveredIdx = intersects[0].index;
          infoPanel.classList.add('visible');
          infoIdx.textContent = `Latent #${hoveredIdx}`;
          infoTime.textContent = `Time: ${((hoveredIdx * audioInfo.samplesPerLatent) / 44100).toFixed(3)}s`;
          container.style.cursor = 'pointer';
        } else {
          hoveredIdx = null;
          infoPanel.classList.remove('visible');
          container.style.cursor = isDragging ? 'grabbing' : 'grab';
        }
      });
      
      container.addEventListener('wheel', (e) => {
        if (isInVR) return;
        e.preventDefault();
        spherical.radius = Math.max(1.5, Math.min(12, spherical.radius + e.deltaY * 0.005));
        updateCamera();
      }, { passive: false });
      
      container.addEventListener('click', () => {
        if (hoveredIdx !== null && !isInVR) playLatent(hoveredIdx);
      });
      
      updateCamera();
      
      // Use setAnimationLoop for WebXR compatibility
      renderer.setAnimationLoop(function() {
        if (autoRotate && !isFullPlaying && !isInVR) {
          spherical.theta += 0.002;
          updateCamera();
        }
        
        // VR input handling
        if (isInVR) {
          updateVRInput();
          
          // Update audio listener position to match camera/head position
          if (audioContext && audioContext.listener) {
            const listener = audioContext.listener;
            
            // Get camera world position
            const camPos = new THREE.Vector3();
            camera.getWorldPosition(camPos);
            
            // Get camera forward direction
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(camera.quaternion);
            
            // Get camera up direction
            const up = new THREE.Vector3(0, 1, 0);
            up.applyQuaternion(camera.quaternion);
            
            // Set listener position and orientation
            if (listener.positionX) {
              // Modern API
              listener.positionX.setValueAtTime(camPos.x, audioContext.currentTime);
              listener.positionY.setValueAtTime(camPos.y, audioContext.currentTime);
              listener.positionZ.setValueAtTime(camPos.z, audioContext.currentTime);
              listener.forwardX.setValueAtTime(forward.x, audioContext.currentTime);
              listener.forwardY.setValueAtTime(forward.y, audioContext.currentTime);
              listener.forwardZ.setValueAtTime(forward.z, audioContext.currentTime);
              listener.upX.setValueAtTime(up.x, audioContext.currentTime);
              listener.upY.setValueAtTime(up.y, audioContext.currentTime);
              listener.upZ.setValueAtTime(up.z, audioContext.currentTime);
            } else {
              // Legacy API fallback
              listener.setPosition(camPos.x, camPos.y, camPos.z);
              listener.setOrientation(forward.x, forward.y, forward.z, up.x, up.y, up.z);
            }
          }
        }
        
        updatePlaybackVisualization();
        renderer.render(scene, camera);
      });
      
      window.addEventListener('resize', () => {
        if (isInVR) return;
        const w = container.clientWidth;
        const h = container.clientHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      });
    }

    // Init
    checkServer();
    loadSongList();
  </script>
</body>
</html>

